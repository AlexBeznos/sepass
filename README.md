# Sepass

Welcome to Sepass app. This is application which allows you to securely share your passwords, secrets, etc.

NOTE: From the feedback document I figured out that i had to add route for events history, but I think that access to such data should be restricted somehow, right now there is no user entity in my application and because of this restriction is not quite secure. So I decided that it does not make sense to create such route.

## How to

Steps to start application:

```bash
docker-compose build
docker-compose run --rm app bundle exec rake db:create db:migrate
docker-compose up
```

Each next time when you need to start application, you can make via one command:

```bash
docker-compose up
```

Steps to start tests:

```bash
docker-compose -f docker-compose.yml -f docker-compose.test.yml build
docker-compose -f docker-compose.yml -f docker-compose.test.yml run --rm app bundle exec rake db:create db:migrate
docker-compose -f docker-compose.yml -f docker-compose.test.yml run --rm app bundle exec rspec spec
```

Each next time you can do it with one command:

```bash
docker-compose -f docker-compose.yml -f docker-compose.test.yml run --rm app bundle exec rspec spec
```

## How it works

In my app I have only two entities: Secret and Event.

### Secret

This is main entity where whole magic happens. It used for storing and managing passwords, secrets.

Schema:

Column name      | Type    | Note
---------------- | ------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
id               | String  | This is auto generated primary key. It generated by trigger with specific function. The function basically concatenates `uuid` with `CURRENT_TIMESTAMP`. It gives me ability to be sure that this value will be unique for each created secret because event if two requests will be created simultaneously `uuid` generator will not give them possibility to be the same(and in reverse).
expired          | Boolean | By this field I know that this secret were fetched at least once already.
expriration_date | Time    | This is date when secret will be expired.
secret           | String  | Encrypted password.
created_at       | Time    | Time with creation date of secret.

For encryptions I using such scheme:

1. `Marshal.dump(secret)` - I using this step to be able to turn any object into string. In my case I pushing here only two types string or array of strings. Because of validation I sure that as input I will have only this specific types and because of this it safe enough for me.
2. `SymmetricEncryption.encrypt(Marshal.dump(secret))` - I am using symmetric encryption with key which I taking from environment variable. As an algorithm I am using AES256.

### Event

This is entity which used for storing all events which happens with secrets.

Schema:

Column name | Type    | Note
----------- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------
id          | Integer | Just a primary key.
data        | JSON    | This field for keeping data about user which made request to api. I'm storing here `user_agent`, `referrer`, `ip`
type        | String  | This is type of request it obligatory can be only `fetch` or `create`
status      | String  | This is status of request and can be `success` if everything went fine and `failure` if secret already expired or it already been taken once.
secret_id   | Integer | Foreign key to `secret` entity.
created_at  | Time    | Time when `event` were created.

## Stack

For this application I used `dry-web-roda` as a basic skeleton. I decided to use it because under the hood it uses `roda` for routing(it pretty fast), `rom` as ORM and I prefer it because it use Repository Pattern and it exclude any unexpected behavior and prevents N+1\. Also I incapsulating all business logic into `dry-transactions` it gives me ability to organize it as step by step pipeline and gives me ability to see what going on from first look.

## API

### POST /secrets

Creation of secret.

#### Request

```http
POST /secrets HTTP/1.1
Content-Type: application/json

{
  "secret":"some sort of secret",
  "expires_at":"2018-10-13 22:50:54 +0300"
}
```

- `secret` - is required and can be string or array of strings
- `expires_at` - not required but if exists should be a date with time

#### Response

```json
{
  "path": "/secrets/fe03ccda-3ddd-4daa-8c8a-a6b32623ad35-153946038697006",
  "url":"http://example.org/secrets/fe03ccda-3ddd-4daa-8c8a-a6b32623ad35-153946038697006"
}
```

URL is build by requested on. So if you request localhost:8080 it will return this host.

### GET /secrets/:id

Path for fetching decoded password, secrets.

#### Request

```http
GET /secrets/fe03ccda-3ddd-4daa-8c8a-a6b32623ad35-153946038697006 HTTP/1.1
Content-Type: application/json
```

#### Response

```json
{
  "secret":"some sort of secret"
}
```
